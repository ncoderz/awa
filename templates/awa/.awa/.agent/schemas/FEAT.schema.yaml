# Structural rules for FEAT-{CODE}-{feature-name}.md files
target-files: ".awa/specs/FEAT-*.md"
description: >
  Non-normative feature context. Explains WHAT the feature is and WHY it exists,
  not HOW to implement it. Uses clear, accessible language. Marked [INFORMATIVE]
  to distinguish from normative REQ/DESIGN documents.
  Prohibited: normative language (SHALL/SHOULD/MAY), acceptance criteria,
  traceability IDs, design decisions, bold formatting.
line-limit: 500

sections:
  # Top-level heading with INFORMATIVE marker
  - heading: ".*\\[INFORMATIVE\\]"
    level: 1
    required: true
    description: >
      Document title including [INFORMATIVE] marker.
      Format: # Feature Context: {Feature Name} [INFORMATIVE]

  # Problem section
  - heading: "Problem"
    level: 2
    required: true
    description: >
      Why this feature exists. What pain point or gap it addresses.
      Written from the user's perspective.

  # Conceptual Model section
  - heading: "Conceptual Model"
    level: 2
    required: true
    description: >
      How users should think about this feature. Mental model, key abstractions,
      and relationships between concepts. May include diagrams.

  # Scenarios section with repeatable scenario headings
  - heading: "Scenarios"
    level: 2
    required: true
    description: >
      Concrete usage narratives illustrating the feature in action. Each
      scenario describes a realistic user situation and expected outcome.
    children:
      - heading: "Scenario \\d+:.*"
        level: 3
        repeatable: true
        required: true
        description: >
          Individual scenario. Format: ### Scenario N: {Title}
          Contains a narrative paragraph describing the user situation.

  # Optional sections
  - heading: "Background"
    level: 2
    description: "Additional context: history, prior art, references."

  - heading: "Glossary"
    level: 2
    description: "Domain terms. Format: - TERM: Definition"

  - heading: "Stakeholders"
    level: 2
    description: "Roles related to this feature. Format: - ROLE: Relationship"

  - heading: "Diagrams"
    level: 2
    description: "Supplementary mermaid diagrams for the conceptual model."

  - heading: "Non-Normative Notes"
    level: 2
    description: "Recommendations, best practices, or explanatory content that is not testable."

  - heading: "Change Log"
    level: 2
    description: "Version history. Format: - {version} ({date}): {changes}"

sections-prohibited:
  - "SHALL "
  - "SHOULD "
  - "MAY "
  - "**"
  - "_AC-"
  - "_P-"
  - "IMPLEMENTS:"
  - "VALIDATES:"

example: |
  # Template Engine Feature Context [INFORMATIVE]

  ## Problem

  Developers need to generate AI agent configuration files across multiple
  projects consistently. Manual creation is error-prone, time-consuming, and
  leads to drift between projects. There is no standard way to conditionally
  include or exclude configuration sections based on project needs.

  ## Conceptual Model

  The template engine treats configuration files as templates that can be
  rendered with a set of feature flags. Users think of features as toggles â€”
  enable "copilot" to get GitHub Copilot config, enable "claude" for Claude
  config, etc. The engine resolves which template files to include, renders
  them with the active feature set, and writes the output.

  Key abstractions:
  - TEMPLATE: A file with optional Eta expressions
  - FEATURE FLAG: A named toggle that controls conditional rendering
  - PARTIAL: A reusable template fragment included by other templates
  - PRESET: A named bundle of feature flags

  ## Scenarios

  ### Scenario 1: First-time Setup

  A developer starts a new project and wants to add AI agent configuration
  for GitHub Copilot and Claude. They run `awa template generate --features copilot,claude`
  and get a complete set of configuration files tailored to those two agents.

  ### Scenario 2: Adding a New Agent

  An existing project already has Copilot configuration. The developer adds
  Cursor support by running `awa template generate --features copilot,cursor`. The engine
  merges the new feature without disrupting existing configuration.

  ### Scenario 3: Previewing Changes

  Before applying changes, the developer runs `awa template diff` to see what files
  would be added, modified, or removed. This gives confidence before committing.

  ## Background

  Prior art includes tools like cookiecutter (Python), degit (JS), and Yeoman.
  These focus on one-time scaffolding. awa differs by supporting re-generation.

  ## Glossary

  - ETA: The template rendering library used by awa
  - FEATURE FLAG: A string identifier that enables conditional template content
  - PARTIAL: A template file prefixed with `_` that can be included by other templates

  ## Change Log

  - 1.0.0 (2025-01-10): Initial feature context
